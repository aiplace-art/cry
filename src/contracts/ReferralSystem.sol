// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import "@openzeppelin/contracts/access/Ownable.sol";
import "@openzeppelin/contracts/utils/ReentrancyGuard.sol";
import "@openzeppelin/contracts/utils/Pausable.sol";

/**
 * @title HypeAI Referral System
 * @notice Automated referral tracking and reward distribution for HYPEAI token sales
 * @dev Integrates with HypeAIPrivateSale contract to track purchases and distribute rewards
 *
 * Features:
 * - Multi-tier referral rewards (5% direct, 2% second-tier)
 * - Flexible reward payment (HYPE tokens OR USDT)
 * - Anti-fraud protection (no self-referral, max caps)
 * - Automatic reward calculation and distribution
 * - Comprehensive statistics tracking
 * - Emergency pause functionality
 */
contract HypeAIReferralSystem is Ownable, ReentrancyGuard, Pausable {

    // ============ STATE VARIABLES ============

    /// @notice HYPEAI token contract
    IERC20 public immutable hypeToken;

    /// @notice USDT token contract for alternative rewards
    IERC20 public immutable usdtToken;

    /// @notice Private sale contract (authorized to call recordPurchase)
    address public privateSaleContract;

    /// @notice Referral reward percentage (in basis points: 100 = 1%)
    uint256 public constant DIRECT_REFERRAL_REWARD = 1000; // 10%

    /// @notice Second-tier referral reward percentage
    uint256 public constant SECOND_TIER_REWARD = 500; // 5%

    /// @notice Third-tier referral reward percentage
    uint256 public constant THIRD_TIER_REWARD = 200; // 2%

    /// @notice Maximum reward cap per referrer in USD
    uint256 public constant MAX_REWARD_CAP_USD = 10000; // $10,000 max earnings

    /// @notice Minimum purchase amount to count as referral in USD (10B tokenomics: Ã—10)
    uint256 public constant MIN_REFERRAL_PURCHASE = 400; // $400

    /// @notice Basis points denominator
    uint256 private constant BASIS_POINTS = 10000;

    // ============ STRUCTS ============

    /**
     * @notice Comprehensive referral data structure
     * @param referrer Address of the user who referred this account
     * @param secondTierReferrer Address of the referrer's referrer (for 2-tier rewards)
     * @param thirdTierReferrer Address of the second-tier referrer's referrer (for 3-tier rewards)
     * @param totalReferred Total number of users referred
     * @param totalVolume Total USD volume generated by referrals
     * @param pendingRewardsUSD Pending rewards in USD value
     * @param totalEarnedUSD Total USD value earned (all-time)
     * @param totalClaimedUSD Total USD value claimed
     * @param rewardInTokens True = claim in HYPE tokens, False = claim in USDT
     * @param isActive Whether this referral account is active
     * @param level Current referral level (0=Bronze, 1=Silver, 2=Gold, 3=Platinum)
     * @param milestoneRewards Pending milestone rewards in USD
     */
    struct ReferralData {
        address referrer;
        address secondTierReferrer;
        address thirdTierReferrer;
        uint256 totalReferred;
        uint256 totalVolume;
        uint256 pendingRewardsUSD;
        uint256 totalEarnedUSD;
        uint256 totalClaimedUSD;
        bool rewardInTokens;
        bool isActive;
        uint8 level;
        uint256 milestoneRewards;
    }

    // ============ LEVEL CONSTANTS ============

    /// @notice Referral count thresholds for each level
    uint256 public constant BRONZE_THRESHOLD = 5;
    uint256 public constant SILVER_THRESHOLD = 20;
    uint256 public constant GOLD_THRESHOLD = 50;
    uint256 public constant PLATINUM_THRESHOLD = 100;

    /// @notice Bonus multipliers for each level (in basis points: 10000 = 1x)
    uint256 public constant BRONZE_MULTIPLIER = 10000; // 1x (no bonus)
    uint256 public constant SILVER_MULTIPLIER = 12500; // 1.25x
    uint256 public constant GOLD_MULTIPLIER = 15000; // 1.5x
    uint256 public constant PLATINUM_MULTIPLIER = 20000; // 2x

    /// @notice Milestone reward thresholds and amounts (in USD)
    uint256[5] public MILESTONE_THRESHOLDS = [10, 25, 50, 100, 250];
    uint256[5] public MILESTONE_REWARDS = [50, 150, 350, 800, 2500];

    // ============ MAPPINGS ============

    /// @notice Mapping of user address to their referral data
    mapping(address => ReferralData) public referrals;

    /// @notice Track which milestones have been claimed by each user
    mapping(address => mapping(uint256 => bool)) public claimedMilestones;

    /// @notice Mapping to track referred users by referrer
    mapping(address => address[]) public referredUsers;

    /// @notice Blacklist for fraud prevention
    mapping(address => bool) public blacklisted;

    /// @notice Track if user has registered a referral
    mapping(address => bool) public hasReferrer;

    // ============ EVENTS ============

    event ReferralRegistered(
        address indexed referee,
        address indexed referrer,
        address indexed secondTierReferrer
    );

    event PurchaseRecorded(
        address indexed buyer,
        uint256 usdAmount,
        uint256 tokensAmount,
        address indexed directReferrer,
        uint256 directReward,
        address indexed secondTierReferrer,
        uint256 secondTierReward
    );

    event RewardsClaimed(
        address indexed user,
        uint256 usdValue,
        uint256 tokenAmount,
        bool inTokens
    );

    event RewardPreferenceChanged(
        address indexed user,
        bool inTokens
    );

    event PrivateSaleContractUpdated(
        address indexed oldContract,
        address indexed newContract
    );

    event UserBlacklisted(address indexed user, bool status);

    event EmergencyWithdrawal(
        address indexed token,
        address indexed recipient,
        uint256 amount
    );

    event LevelUpgraded(
        address indexed user,
        uint8 oldLevel,
        uint8 newLevel,
        uint256 newMultiplier
    );

    event MilestoneReached(
        address indexed user,
        uint256 milestoneIndex,
        uint256 rewardAmount,
        uint256 totalReferrals
    );

    // ============ MODIFIERS ============

    /**
     * @notice Only allow calls from the authorized private sale contract
     */
    modifier onlyPrivateSale() {
        require(msg.sender == privateSaleContract, "Only private sale contract");
        _;
    }

    /**
     * @notice Prevent blacklisted users from interacting
     */
    modifier notBlacklisted(address _user) {
        require(!blacklisted[_user], "User is blacklisted");
        _;
    }

    // ============ CONSTRUCTOR ============

    /**
     * @notice Initialize the referral system
     * @param _hypeToken HYPEAI token address
     * @param _usdtToken USDT token address
     * @param _privateSaleContract Initial private sale contract address
     */
    constructor(
        address _hypeToken,
        address _usdtToken,
        address _privateSaleContract
    ) Ownable(msg.sender) {
        require(_hypeToken != address(0), "Invalid HYPE token");
        require(_usdtToken != address(0), "Invalid USDT token");
        require(_privateSaleContract != address(0), "Invalid sale contract");

        hypeToken = IERC20(_hypeToken);
        usdtToken = IERC20(_usdtToken);
        privateSaleContract = _privateSaleContract;
    }

    // ============ EXTERNAL FUNCTIONS ============

    /**
     * @notice Register a referral relationship
     * @param _referee Address being referred
     * @param _referrer Address of the referrer
     * @dev Can only be called once per referee, prevents self-referral and circular references
     */
    function registerReferral(
        address _referee,
        address _referrer
    )
        external
        whenNotPaused
        notBlacklisted(_referee)
        notBlacklisted(_referrer)
    {
        require(_referee != address(0), "Invalid referee");
        require(_referrer != address(0), "Invalid referrer");
        require(_referee != _referrer, "Cannot refer yourself");
        require(!hasReferrer[_referee], "Already has referrer");
        require(_referee != owner(), "Owner cannot be referred");

        // Prevent circular referrals
        require(referrals[_referrer].referrer != _referee, "Circular referral");

        // Get second-tier referrer (referrer's referrer)
        address secondTier = referrals[_referrer].referrer;

        // Get third-tier referrer (second tier's referrer)
        address thirdTier = secondTier != address(0) ? referrals[secondTier].referrer : address(0);

        // Initialize referral data
        referrals[_referee] = ReferralData({
            referrer: _referrer,
            secondTierReferrer: secondTier,
            thirdTierReferrer: thirdTier,
            totalReferred: 0,
            totalVolume: 0,
            pendingRewardsUSD: 0,
            totalEarnedUSD: 0,
            totalClaimedUSD: 0,
            rewardInTokens: true, // Default to HYPE tokens
            isActive: true,
            level: 0, // Start at Bronze
            milestoneRewards: 0
        });

        hasReferrer[_referee] = true;
        referredUsers[_referrer].push(_referee);

        emit ReferralRegistered(_referee, _referrer, secondTier);
    }

    /**
     * @notice Record a purchase and calculate referral rewards
     * @param _buyer Address of the buyer
     * @param _usdAmount USD amount spent
     * @param _tokensAmount HYPE tokens purchased
     * @dev Only callable by authorized private sale contract
     */
    function recordPurchase(
        address _buyer,
        uint256 _usdAmount,
        uint256 _tokensAmount
    )
        external
        onlyPrivateSale
        whenNotPaused
        notBlacklisted(_buyer)
    {
        require(_usdAmount >= MIN_REFERRAL_PURCHASE, "Purchase too small");

        address directReferrer = referrals[_buyer].referrer;

        // If buyer has no referrer, no rewards to distribute
        if (directReferrer == address(0)) {
            emit PurchaseRecorded(_buyer, _usdAmount, _tokensAmount, address(0), 0, address(0), 0);
            return;
        }

        uint256 directReward = 0;
        uint256 secondTierReward = 0;

        // Calculate and distribute direct referral reward (10% with bonus multiplier)
        if (!blacklisted[directReferrer] && referrals[directReferrer].isActive) {
            uint256 baseReward = (_usdAmount * DIRECT_REFERRAL_REWARD) / BASIS_POINTS;

            // Apply level bonus multiplier
            uint8 level = referrals[directReferrer].level;
            uint256 multiplier = getBonusMultiplier(level);
            directReward = (baseReward * multiplier) / BASIS_POINTS;

            // Check max cap
            if (referrals[directReferrer].totalEarnedUSD + directReward <= MAX_REWARD_CAP_USD) {
                referrals[directReferrer].pendingRewardsUSD += directReward;
                referrals[directReferrer].totalEarnedUSD += directReward;
                referrals[directReferrer].totalReferred += 1;
                referrals[directReferrer].totalVolume += _usdAmount;

                // Check and update level
                _updateLevel(directReferrer);

                // Check milestones
                _checkMilestones(directReferrer);
            } else {
                directReward = 0; // Cap reached, no reward
            }
        }

        // Calculate and distribute second-tier reward (5%)
        address secondTierReferrer = referrals[_buyer].secondTierReferrer;
        if (
            secondTierReferrer != address(0) &&
            !blacklisted[secondTierReferrer] &&
            referrals[secondTierReferrer].isActive
        ) {
            secondTierReward = (_usdAmount * SECOND_TIER_REWARD) / BASIS_POINTS;

            // Check max cap
            if (referrals[secondTierReferrer].totalEarnedUSD + secondTierReward <= MAX_REWARD_CAP_USD) {
                referrals[secondTierReferrer].pendingRewardsUSD += secondTierReward;
                referrals[secondTierReferrer].totalEarnedUSD += secondTierReward;
            } else {
                secondTierReward = 0; // Cap reached
            }
        }

        // Calculate and distribute third-tier reward (2%)
        address thirdTierReferrer = referrals[_buyer].thirdTierReferrer;
        uint256 thirdTierReward = 0;
        if (
            thirdTierReferrer != address(0) &&
            !blacklisted[thirdTierReferrer] &&
            referrals[thirdTierReferrer].isActive
        ) {
            thirdTierReward = (_usdAmount * THIRD_TIER_REWARD) / BASIS_POINTS;

            // Check max cap
            if (referrals[thirdTierReferrer].totalEarnedUSD + thirdTierReward <= MAX_REWARD_CAP_USD) {
                referrals[thirdTierReferrer].pendingRewardsUSD += thirdTierReward;
                referrals[thirdTierReferrer].totalEarnedUSD += thirdTierReward;
            } else {
                thirdTierReward = 0; // Cap reached
            }
        }

        emit PurchaseRecorded(
            _buyer,
            _usdAmount,
            _tokensAmount,
            directReferrer,
            directReward,
            secondTierReferrer,
            secondTierReward
        );
    }

    /**
     * @notice Claim pending referral rewards
     * @param _inTokens True to receive HYPE tokens, false for USDT
     * @dev Calculates token amount based on current token price ($0.00008 - 10B tokenomics)
     */
    function claimRewards(bool _inTokens)
        external
        nonReentrant
        whenNotPaused
        notBlacklisted(msg.sender)
    {
        ReferralData storage userData = referrals[msg.sender];

        require(userData.pendingRewardsUSD > 0, "No pending rewards");
        require(userData.isActive, "Account not active");

        uint256 rewardUSD = userData.pendingRewardsUSD;
        userData.pendingRewardsUSD = 0;
        userData.totalClaimedUSD += rewardUSD;

        if (_inTokens) {
            // Calculate HYPE tokens (1 HYPE = $0.00008, so tokens = usdValue / 0.00008 = usdValue * 12500)
            uint256 tokenAmount = rewardUSD * 12500 * 10**18;

            require(
                hypeToken.balanceOf(address(this)) >= tokenAmount,
                "Insufficient HYPE tokens in contract"
            );

            require(
                hypeToken.transfer(msg.sender, tokenAmount),
                "HYPE transfer failed"
            );

            emit RewardsClaimed(msg.sender, rewardUSD, tokenAmount, true);
        } else {
            // Pay in USDT (1:1 with USD)
            uint256 usdtAmount = rewardUSD * 10**18; // USDT has 18 decimals on BSC

            require(
                usdtToken.balanceOf(address(this)) >= usdtAmount,
                "Insufficient USDT in contract"
            );

            require(
                usdtToken.transfer(msg.sender, usdtAmount),
                "USDT transfer failed"
            );

            emit RewardsClaimed(msg.sender, rewardUSD, usdtAmount, false);
        }
    }

    /**
     * @notice Change reward payment preference
     * @param _inTokens True for HYPE tokens, false for USDT
     */
    function setRewardPreference(bool _inTokens) external {
        referrals[msg.sender].rewardInTokens = _inTokens;
        emit RewardPreferenceChanged(msg.sender, _inTokens);
    }

    /**
     * @notice Claim milestone rewards
     * @dev Claims all unclaimed milestones at once
     */
    function claimMilestoneRewards()
        external
        nonReentrant
        whenNotPaused
        notBlacklisted(msg.sender)
    {
        ReferralData storage userData = referrals[msg.sender];
        require(userData.milestoneRewards > 0, "No milestone rewards");

        uint256 rewardUSD = userData.milestoneRewards;
        userData.milestoneRewards = 0;
        userData.pendingRewardsUSD += rewardUSD;
    }

    // ============ INTERNAL FUNCTIONS ============

    /**
     * @notice Update user level based on total referrals
     * @param _user User address to update
     */
    function _updateLevel(address _user) internal {
        ReferralData storage userData = referrals[_user];
        uint8 oldLevel = userData.level;
        uint8 newLevel = calculateLevel(userData.totalReferred);

        if (newLevel > oldLevel) {
            userData.level = newLevel;
            uint256 newMultiplier = getBonusMultiplier(newLevel);
            emit LevelUpgraded(_user, oldLevel, newLevel, newMultiplier);
        }
    }

    /**
     * @notice Check and award milestone rewards
     * @param _user User address to check
     */
    function _checkMilestones(address _user) internal {
        ReferralData storage userData = referrals[_user];
        uint256 totalRefs = userData.totalReferred;

        for (uint256 i = 0; i < 5; i++) {
            if (totalRefs >= MILESTONE_THRESHOLDS[i] && !claimedMilestones[_user][i]) {
                claimedMilestones[_user][i] = true;
                userData.milestoneRewards += MILESTONE_REWARDS[i];
                emit MilestoneReached(_user, i, MILESTONE_REWARDS[i], totalRefs);
            }
        }
    }

    /**
     * @notice Calculate user level based on referral count
     * @param totalReferrals Number of referrals
     * @return level 0=Bronze, 1=Silver, 2=Gold, 3=Platinum
     */
    function calculateLevel(uint256 totalReferrals) internal pure returns (uint8 level) {
        if (totalReferrals >= PLATINUM_THRESHOLD) return 3;
        if (totalReferrals >= GOLD_THRESHOLD) return 2;
        if (totalReferrals >= SILVER_THRESHOLD) return 1;
        return 0;
    }

    /**
     * @notice Get bonus multiplier for a level
     * @param level User level (0-3)
     * @return multiplier Bonus multiplier in basis points
     */
    function getBonusMultiplier(uint8 level) internal pure returns (uint256 multiplier) {
        if (level == 3) return PLATINUM_MULTIPLIER;
        if (level == 2) return GOLD_MULTIPLIER;
        if (level == 1) return SILVER_MULTIPLIER;
        return BRONZE_MULTIPLIER;
    }

    // ============ VIEW FUNCTIONS ============

    /**
     * @notice Get comprehensive referral statistics for a user
     * @param _user Address to query
     * @return referrer Direct referrer address
     * @return secondTierReferrer Second-tier referrer address
     * @return totalReferred Number of direct referrals
     * @return totalVolume Total USD volume from referrals
     * @return pendingRewardsUSD Pending rewards in USD
     * @return totalEarnedUSD Total earned (all-time)
     * @return totalClaimedUSD Total claimed amount
     * @return rewardInTokens Payment preference
     * @return isActive Account status
     */
    function getReferralStats(address _user)
        external
        view
        returns (
            address referrer,
            address secondTierReferrer,
            uint256 totalReferred,
            uint256 totalVolume,
            uint256 pendingRewardsUSD,
            uint256 totalEarnedUSD,
            uint256 totalClaimedUSD,
            bool rewardInTokens,
            bool isActive
        )
    {
        ReferralData memory data = referrals[_user];
        return (
            data.referrer,
            data.secondTierReferrer,
            data.totalReferred,
            data.totalVolume,
            data.pendingRewardsUSD,
            data.totalEarnedUSD,
            data.totalClaimedUSD,
            data.rewardInTokens,
            data.isActive
        );
    }

    /**
     * @notice Get pending rewards for a user in both USD and tokens
     * @param _user Address to query
     * @return usdValue Pending rewards in USD
     * @return hypeTokens Equivalent HYPE tokens at current price (10B tokenomics)
     * @return usdtTokens Equivalent USDT tokens
     */
    function getPendingRewards(address _user)
        external
        view
        returns (
            uint256 usdValue,
            uint256 hypeTokens,
            uint256 usdtTokens
        )
    {
        usdValue = referrals[_user].pendingRewardsUSD;
        hypeTokens = usdValue * 12500 * 10**18; // 1 HYPE = $0.00008 (10B tokenomics)
        usdtTokens = usdValue * 10**18; // 1 USDT = $1
    }

    /**
     * @notice Get list of users referred by an address
     * @param _referrer Referrer address
     * @return Array of referred user addresses
     */
    function getReferredUsers(address _referrer)
        external
        view
        returns (address[] memory)
    {
        return referredUsers[_referrer];
    }

    /**
     * @notice Get leaderboard data (top referrers by volume)
     * @param _addresses Array of addresses to check
     * @return volumes Array of total volumes
     * @return referralCounts Array of referral counts
     */
    function getLeaderboard(address[] calldata _addresses)
        external
        view
        returns (
            uint256[] memory volumes,
            uint256[] memory referralCounts
        )
    {
        volumes = new uint256[](_addresses.length);
        referralCounts = new uint256[](_addresses.length);

        for (uint256 i = 0; i < _addresses.length; i++) {
            volumes[i] = referrals[_addresses[i]].totalVolume;
            referralCounts[i] = referrals[_addresses[i]].totalReferred;
        }
    }

    // ============ ADMIN FUNCTIONS ============

    /**
     * @notice Update the private sale contract address
     * @param _newContract New contract address
     */
    function setPrivateSaleContract(address _newContract) external onlyOwner {
        require(_newContract != address(0), "Invalid contract address");
        address oldContract = privateSaleContract;
        privateSaleContract = _newContract;
        emit PrivateSaleContractUpdated(oldContract, _newContract);
    }

    /**
     * @notice Blacklist or unblacklist a user
     * @param _user User address
     * @param _status True to blacklist, false to unblacklist
     */
    function setBlacklisted(address _user, bool _status) external onlyOwner {
        blacklisted[_user] = _status;
        if (_status) {
            referrals[_user].isActive = false;
        }
        emit UserBlacklisted(_user, _status);
    }

    /**
     * @notice Deactivate a referral account (fraud prevention)
     * @param _user User to deactivate
     */
    function deactivateAccount(address _user) external onlyOwner {
        referrals[_user].isActive = false;
    }

    /**
     * @notice Fund the contract with HYPE tokens for rewards
     * @param _amount Amount of HYPE tokens to fund
     */
    function fundHypeRewards(uint256 _amount) external onlyOwner {
        require(
            hypeToken.transferFrom(msg.sender, address(this), _amount),
            "Transfer failed"
        );
    }

    /**
     * @notice Fund the contract with USDT for rewards
     * @param _amount Amount of USDT to fund
     */
    function fundUsdtRewards(uint256 _amount) external onlyOwner {
        require(
            usdtToken.transferFrom(msg.sender, address(this), _amount),
            "Transfer failed"
        );
    }

    /**
     * @notice Emergency withdrawal of tokens
     * @param _token Token address (HYPE or USDT)
     * @param _amount Amount to withdraw
     */
    function emergencyWithdraw(address _token, uint256 _amount) external onlyOwner {
        require(_token == address(hypeToken) || _token == address(usdtToken), "Invalid token");

        IERC20 token = IERC20(_token);
        require(
            token.transfer(owner(), _amount),
            "Transfer failed"
        );

        emit EmergencyWithdrawal(_token, owner(), _amount);
    }

    /**
     * @notice Pause the contract
     */
    function pause() external onlyOwner {
        _pause();
    }

    /**
     * @notice Unpause the contract
     */
    function unpause() external onlyOwner {
        _unpause();
    }
}
