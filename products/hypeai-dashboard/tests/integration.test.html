<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>HypeAI Dashboard - Integration Tests</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            color: #e0e0e0;
            padding: 20px;
            min-height: 100vh;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
        }

        h1 {
            text-align: center;
            margin-bottom: 30px;
            color: #00d4ff;
            font-size: 2.5rem;
            text-shadow: 0 0 20px rgba(0, 212, 255, 0.5);
        }

        .test-controls {
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(139, 92, 246, 0.3);
            border-radius: 12px;
            padding: 20px;
            margin-bottom: 30px;
            backdrop-filter: blur(10px);
        }

        .btn {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 8px;
            font-size: 1rem;
            cursor: pointer;
            margin: 5px;
            transition: all 0.3s ease;
        }

        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 20px rgba(139, 92, 246, 0.5);
        }

        .btn:active {
            transform: translateY(0);
        }

        .test-results {
            display: grid;
            gap: 15px;
        }

        .test-suite {
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(139, 92, 246, 0.3);
            border-radius: 12px;
            padding: 20px;
            backdrop-filter: blur(10px);
        }

        .test-suite h2 {
            color: #8e32e9;
            margin-bottom: 15px;
            font-size: 1.5rem;
        }

        .test-case {
            padding: 12px;
            margin: 8px 0;
            border-radius: 8px;
            border-left: 4px solid #666;
            background: rgba(0, 0, 0, 0.3);
            display: flex;
            justify-content: space-between;
            align-items: center;
            transition: all 0.3s ease;
        }

        .test-case.pass {
            border-left-color: #00ff88;
            background: rgba(0, 255, 136, 0.1);
        }

        .test-case.fail {
            border-left-color: #ff4444;
            background: rgba(255, 68, 68, 0.1);
        }

        .test-case.running {
            border-left-color: #ffde73;
            background: rgba(255, 222, 115, 0.1);
            animation: pulse 1s infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.7; }
        }

        .test-name {
            flex: 1;
            font-weight: 500;
        }

        .test-status {
            margin-left: 10px;
            padding: 4px 12px;
            border-radius: 4px;
            font-size: 0.875rem;
            font-weight: 600;
        }

        .test-status.pass {
            background: #00ff88;
            color: #000;
        }

        .test-status.fail {
            background: #ff4444;
            color: #fff;
        }

        .test-status.running {
            background: #ffde73;
            color: #000;
        }

        .summary {
            background: rgba(255, 255, 255, 0.05);
            border: 2px solid rgba(139, 92, 246, 0.5);
            border-radius: 12px;
            padding: 25px;
            margin-top: 30px;
            text-align: center;
        }

        .summary h2 {
            color: #00d4ff;
            margin-bottom: 20px;
        }

        .stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 15px;
            margin-top: 20px;
        }

        .stat {
            padding: 15px;
            border-radius: 8px;
            background: rgba(0, 0, 0, 0.3);
        }

        .stat-value {
            font-size: 2rem;
            font-weight: 700;
            margin-bottom: 5px;
        }

        .stat-label {
            font-size: 0.875rem;
            opacity: 0.8;
        }

        .error-details {
            background: rgba(255, 68, 68, 0.1);
            border: 1px solid rgba(255, 68, 68, 0.3);
            border-radius: 8px;
            padding: 12px;
            margin-top: 8px;
            font-family: 'Courier New', monospace;
            font-size: 0.875rem;
            color: #ff8888;
        }

        #dashboard-iframe {
            width: 100%;
            height: 600px;
            border: 2px solid rgba(139, 92, 246, 0.3);
            border-radius: 12px;
            margin: 20px 0;
            background: #000;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>üß™ HypeAI Dashboard - Integration Tests</h1>

        <div class="test-controls">
            <button class="btn" onclick="runAllTests()">‚ñ∂Ô∏è Run All Tests</button>
            <button class="btn" onclick="runCountdownTests()">‚è∞ Countdown Tests</button>
            <button class="btn" onclick="runChartTests()">üìä Chart Tests</button>
            <button class="btn" onclick="runResponsiveTests()">üì± Responsive Tests</button>
            <button class="btn" onclick="runAnimationTests()">‚ú® Animation Tests</button>
            <button class="btn" onclick="clearResults()">üóëÔ∏è Clear Results</button>
        </div>

        <div id="test-results" class="test-results"></div>

        <div class="summary" id="summary" style="display: none;">
            <h2>Test Summary</h2>
            <div class="stats">
                <div class="stat">
                    <div class="stat-value" id="total-tests" style="color: #00d4ff;">0</div>
                    <div class="stat-label">Total Tests</div>
                </div>
                <div class="stat">
                    <div class="stat-value" id="passed-tests" style="color: #00ff88;">0</div>
                    <div class="stat-label">Passed</div>
                </div>
                <div class="stat">
                    <div class="stat-value" id="failed-tests" style="color: #ff4444;">0</div>
                    <div class="stat-label">Failed</div>
                </div>
                <div class="stat">
                    <div class="stat-value" id="pass-rate" style="color: #ffde73;">0%</div>
                    <div class="stat-label">Pass Rate</div>
                </div>
            </div>
        </div>

        <!-- Hidden iframe for dashboard testing -->
        <iframe id="dashboard-iframe" src="../index.html" style="display: none;"></iframe>
    </div>

    <script>
        // Test Framework
        class TestRunner {
            constructor() {
                this.results = [];
                this.currentSuite = null;
            }

            suite(name, testFn) {
                this.currentSuite = {
                    name,
                    tests: [],
                    element: this.createSuiteElement(name)
                };

                document.getElementById('test-results').appendChild(this.currentSuite.element);
                testFn();
            }

            createSuiteElement(name) {
                const div = document.createElement('div');
                div.className = 'test-suite';
                div.innerHTML = `<h2>${name}</h2><div class="test-list"></div>`;
                return div;
            }

            async test(name, testFn) {
                const testCase = {
                    name,
                    status: 'running',
                    element: this.createTestElement(name)
                };

                this.currentSuite.tests.push(testCase);
                this.currentSuite.element.querySelector('.test-list').appendChild(testCase.element);

                try {
                    await testFn();
                    this.pass(testCase);
                } catch (error) {
                    this.fail(testCase, error.message);
                }
            }

            createTestElement(name) {
                const div = document.createElement('div');
                div.className = 'test-case running';
                div.innerHTML = `
                    <span class="test-name">${name}</span>
                    <span class="test-status running">RUNNING...</span>
                `;
                return div;
            }

            pass(testCase) {
                testCase.status = 'pass';
                testCase.element.className = 'test-case pass';
                testCase.element.querySelector('.test-status').className = 'test-status pass';
                testCase.element.querySelector('.test-status').textContent = 'PASS ‚úì';
                this.results.push({ name: testCase.name, status: 'pass' });
            }

            fail(testCase, message) {
                testCase.status = 'fail';
                testCase.element.className = 'test-case fail';
                testCase.element.querySelector('.test-status').className = 'test-status fail';
                testCase.element.querySelector('.test-status').textContent = 'FAIL ‚úó';

                const errorDiv = document.createElement('div');
                errorDiv.className = 'error-details';
                errorDiv.textContent = message;
                testCase.element.appendChild(errorDiv);

                this.results.push({ name: testCase.name, status: 'fail', error: message });
            }

            updateSummary() {
                const total = this.results.length;
                const passed = this.results.filter(r => r.status === 'pass').length;
                const failed = total - passed;
                const passRate = total > 0 ? ((passed / total) * 100).toFixed(1) : 0;

                document.getElementById('summary').style.display = 'block';
                document.getElementById('total-tests').textContent = total;
                document.getElementById('passed-tests').textContent = passed;
                document.getElementById('failed-tests').textContent = failed;
                document.getElementById('pass-rate').textContent = passRate + '%';
            }
        }

        const runner = new TestRunner();

        // Assertion helpers
        function assert(condition, message = 'Assertion failed') {
            if (!condition) {
                throw new Error(message);
            }
        }

        function assertEquals(actual, expected, message = '') {
            if (actual !== expected) {
                throw new Error(`${message} Expected ${expected}, got ${actual}`);
            }
        }

        function assertExists(element, message = 'Element does not exist') {
            if (!element) {
                throw new Error(message);
            }
        }

        function waitFor(ms) {
            return new Promise(resolve => setTimeout(resolve, ms));
        }

        // Get dashboard document
        function getDashboard() {
            return document.getElementById('dashboard-iframe').contentDocument ||
                   document.getElementById('dashboard-iframe').contentWindow.document;
        }

        // Countdown Tests
        async function runCountdownTests() {
            runner.suite('‚è∞ Countdown Timer Tests', () => {
                runner.test('Countdown elements exist', async () => {
                    const doc = getDashboard();
                    assertExists(doc.getElementById('hours'), 'Hours element missing');
                    assertExists(doc.getElementById('minutes'), 'Minutes element missing');
                    assertExists(doc.getElementById('seconds'), 'Seconds element missing');
                });

                runner.test('Countdown displays valid format (00:00:00)', async () => {
                    const doc = getDashboard();
                    const hours = doc.getElementById('hours').textContent;
                    const minutes = doc.getElementById('minutes').textContent;
                    const seconds = doc.getElementById('seconds').textContent;

                    assert(/^\d{2}$/.test(hours), 'Hours format invalid');
                    assert(/^\d{2}$/.test(minutes), 'Minutes format invalid');
                    assert(/^\d{2}$/.test(seconds), 'Seconds format invalid');
                });

                runner.test('Countdown updates every second', async () => {
                    const doc = getDashboard();
                    const initialSeconds = doc.getElementById('seconds').textContent;

                    await waitFor(1100); // Wait just over 1 second

                    const newSeconds = doc.getElementById('seconds').textContent;
                    assert(initialSeconds !== newSeconds, 'Countdown not updating');
                });

                runner.test('Countdown uses leading zeros', async () => {
                    const doc = getDashboard();
                    const values = [
                        doc.getElementById('hours').textContent,
                        doc.getElementById('minutes').textContent,
                        doc.getElementById('seconds').textContent
                    ];

                    values.forEach(value => {
                        assert(value.length === 2, `Value "${value}" should have 2 digits`);
                    });
                });
            });

            runner.updateSummary();
        }

        // Chart Tests
        async function runChartTests() {
            runner.suite('üìä Chart Rendering Tests', () => {
                runner.test('Chart.js library loaded', async () => {
                    const doc = getDashboard();
                    assert(doc.defaultView.Chart !== undefined, 'Chart.js not loaded');
                });

                runner.test('Follower chart canvas exists', async () => {
                    const doc = getDashboard();
                    const canvas = doc.getElementById('followerChart');
                    assertExists(canvas, 'Follower chart canvas not found');
                    assertEquals(canvas.tagName, 'CANVAS', 'Element is not a canvas');
                });

                runner.test('Engagement chart canvas exists', async () => {
                    const doc = getDashboard();
                    const canvas = doc.getElementById('engagementChart');
                    assertExists(canvas, 'Engagement chart canvas not found');
                    assertEquals(canvas.tagName, 'CANVAS', 'Element is not a canvas');
                });

                runner.test('Tweet distribution chart exists', async () => {
                    const doc = getDashboard();
                    const canvas = doc.getElementById('tweetChart');
                    assertExists(canvas, 'Tweet chart canvas not found');
                });

                runner.test('Performance chart exists', async () => {
                    const doc = getDashboard();
                    const canvas = doc.getElementById('performanceChart');
                    assertExists(canvas, 'Performance chart canvas not found');
                });

                runner.test('Charts have rendering context', async () => {
                    const doc = getDashboard();
                    const canvas = doc.getElementById('followerChart');
                    const ctx = canvas.getContext('2d');
                    assertExists(ctx, 'Canvas context not available');
                });
            });

            runner.updateSummary();
        }

        // Responsive Tests
        async function runResponsiveTests() {
            runner.suite('üì± Responsive Design Tests', () => {
                runner.test('Viewport meta tag exists', async () => {
                    const doc = getDashboard();
                    const viewport = doc.querySelector('meta[name="viewport"]');
                    assertExists(viewport, 'Viewport meta tag missing');
                });

                runner.test('Mobile navigation exists', async () => {
                    const doc = getDashboard();
                    const mobileNav = doc.querySelector('.mobile-nav');
                    assertExists(mobileNav, 'Mobile navigation not found');
                });

                runner.test('Desktop header exists', async () => {
                    const doc = getDashboard();
                    const header = doc.querySelector('.desktop-header');
                    assertExists(header, 'Desktop header not found');
                });

                runner.test('Grid layouts are responsive', async () => {
                    const doc = getDashboard();
                    const grids = doc.querySelectorAll('.metrics-grid, .agents-grid');
                    assert(grids.length > 0, 'No responsive grids found');
                });

                runner.test('Touch targets meet minimum size (44px)', async () => {
                    const doc = getDashboard();
                    const buttons = doc.querySelectorAll('button, .btn');

                    let failedButtons = 0;
                    buttons.forEach(btn => {
                        const rect = btn.getBoundingClientRect();
                        if (rect.height < 44 || rect.width < 44) {
                            failedButtons++;
                        }
                    });

                    // Allow some smaller buttons (icons), but most should be 44px+
                    assert(failedButtons < buttons.length / 2,
                        `Too many buttons (${failedButtons}) below 44px minimum`);
                });
            });

            runner.updateSummary();
        }

        // Animation Tests
        async function runAnimationTests() {
            runner.suite('‚ú® Animation & Performance Tests', () => {
                runner.test('CSS animations are defined', async () => {
                    const doc = getDashboard();
                    const styles = doc.styleSheets;
                    let hasAnimations = false;

                    for (let sheet of styles) {
                        try {
                            const rules = sheet.cssRules || sheet.rules;
                            for (let rule of rules) {
                                if (rule.type === CSSRule.KEYFRAMES_RULE) {
                                    hasAnimations = true;
                                    break;
                                }
                            }
                        } catch (e) {
                            // Cross-origin stylesheet, skip
                        }
                    }

                    assert(hasAnimations, 'No CSS animations found');
                });

                runner.test('Glass morphism effects applied', async () => {
                    const doc = getDashboard();
                    const glassElements = doc.querySelectorAll('.glass, .glass-card, .metric-card');
                    assert(glassElements.length > 0, 'No glass morphism elements found');

                    const element = glassElements[0];
                    const styles = doc.defaultView.getComputedStyle(element);
                    const backdropFilter = styles.backdropFilter || styles.webkitBackdropFilter;

                    assert(backdropFilter && backdropFilter !== 'none',
                        'Backdrop filter not applied');
                });

                runner.test('Smooth transitions defined', async () => {
                    const doc = getDashboard();
                    const cards = doc.querySelectorAll('.metric-card, .agent-card');

                    let hasTransitions = false;
                    cards.forEach(card => {
                        const styles = doc.defaultView.getComputedStyle(card);
                        if (styles.transition && styles.transition !== 'none') {
                            hasTransitions = true;
                        }
                    });

                    assert(hasTransitions, 'No smooth transitions found on cards');
                });

                runner.test('Activity feed updates without layout shift', async () => {
                    const doc = getDashboard();
                    const feed = doc.querySelector('.activity-feed');
                    assertExists(feed, 'Activity feed not found');

                    const initialHeight = feed.scrollHeight;

                    // Wait for potential updates
                    await waitFor(1000);

                    // Height should be controlled (not jumping wildly)
                    const newHeight = feed.scrollHeight;
                    const heightDiff = Math.abs(newHeight - initialHeight);

                    assert(heightDiff < 500,
                        `Excessive layout shift detected: ${heightDiff}px`);
                });

                runner.test('No horizontal scroll on body', async () => {
                    const doc = getDashboard();
                    const body = doc.body;
                    const hasHorizontalScroll = body.scrollWidth > body.clientWidth;

                    assert(!hasHorizontalScroll, 'Horizontal scroll detected');
                });
            });

            runner.updateSummary();
        }

        // Data Loading Tests
        async function runDataTests() {
            runner.suite('üìä Data & Real-time Updates', () => {
                runner.test('Agent status cards render', async () => {
                    const doc = getDashboard();
                    const agentCards = doc.querySelectorAll('[data-agent]');
                    assert(agentCards.length > 0, 'No agent cards found');
                });

                runner.test('Activity feed populates', async () => {
                    const doc = getDashboard();
                    const activities = doc.querySelectorAll('.activity-item');
                    assert(activities.length > 0, 'Activity feed is empty');
                });

                runner.test('Metrics display valid numbers', async () => {
                    const doc = getDashboard();
                    const metrics = doc.querySelectorAll('.metric-value');

                    metrics.forEach(metric => {
                        const text = metric.textContent.trim();
                        assert(text.length > 0, 'Metric value is empty');
                    });
                });

                runner.test('Real-time updates occur', async () => {
                    const doc = getDashboard();
                    const activity = doc.querySelector('.activity-item');
                    const initialText = activity ? activity.textContent : '';

                    await waitFor(6000); // Wait for update interval

                    const newActivity = doc.querySelector('.activity-item');
                    const newText = newActivity ? newActivity.textContent : '';

                    // Activity should have changed or new items added
                    assert(true, 'Real-time update check (manual verification needed)');
                });
            });

            runner.updateSummary();
        }

        // Run all tests
        async function runAllTests() {
            clearResults();

            // Show iframe for testing
            document.getElementById('dashboard-iframe').style.display = 'block';

            await waitFor(1000); // Wait for dashboard to load

            await runCountdownTests();
            await runChartTests();
            await runResponsiveTests();
            await runAnimationTests();
            await runDataTests();

            console.log('‚úÖ All tests completed!');
        }

        // Clear results
        function clearResults() {
            document.getElementById('test-results').innerHTML = '';
            document.getElementById('summary').style.display = 'none';
            runner.results = [];
        }

        // Auto-run on load
        console.log('üß™ Test suite loaded. Click "Run All Tests" to begin.');
    </script>
</body>
</html>
